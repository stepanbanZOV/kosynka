import pygame  # Импортируем библиотеку Pygame для создания игры
import sys  # Импортируем модуль sys для завершения программы
import os  # Импортируем модуль os для работы с путями к файлам
import random  # Импортируем модуль random для случайного перемешивания карт

# Инициализация Pygame
pygame.init()  # Инициализируем все модули Pygame

# Параметры окна
size = width, height = 960, 720  # Размеры окна игры
screen = pygame.display.set_mode(size)  # Создаем окно игры с заданными размерами
pygame.display.set_caption("Pasjans Kosynka")  # Устанавливаем заголовок окна
pygame.mixer.music.load("Pasjans-Kosynka-OST-Glimmer.mp3")
pygame.mixer.music.play(-1)

# Загрузка изображений карт
def load_card_images():
    card_images = {}  # Словарь для хранения изображений карт
    suits = ['hearts', 'diamonds', 'clubs', 'spades']  # Масти карт
    values = ['ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'jack', 'queen', 'king']  # Значения карт

    for suit in suits:  # Для каждой масти
        for value in values:  # Для каждого значения
            card_name = f"{value}_of_{suit}"  # Имя файла с изображением карты
            image_path = os.path.join('assets', 'cards', f"{card_name}.png")  # Путь к файлу изображения
            card_images[card_name] = pygame.image.load(image_path)  # Загрузка изображения карты в словарь

    return card_images  # Возвращаем словарь с изображениями карт

card_images = load_card_images()  # Загружаем изображения карт

# Загрузка изображения обратной стороны карты
back_image = pygame.image.load(os.path.join('assets', 'cards', 'back.png'))  # Загружаем изображение обратной стороны карты

# Класс для представления карты
class Card:
    def __init__(self, name, image, value, suit, color):
        self.name = name  # Имя карты (например, "ace_of_spades")
        self.image = image  # Изображение карты
        self.value = value  # Значение карты (1 для туза, 11 для валета и т.д.)
        self.suit = suit  # Масть карты
        self.color = color  # Цвет карты (красный или черный)
        self.face_up = False  # Лицевая сторона карты вверх (по умолчанию - нет)

    def draw(self, screen, pos):
        # Рисуем карту лицевой стороной вверх или обратной стороной, в зависимости от состояния face_up
        screen.blit(self.image if self.face_up else back_image, pos)

# Класс для представления столбца карт
class Column:
    def __init__(self):
        self.cards = []  # Список карт в столбце

    def add_card(self, card):
        self.cards.append(card)  # Добавляем карту в столбец

    def remove_cards(self, start_idx):
        removed_cards = self.cards[start_idx:]  # Удаляем карты, начиная с указанного индекса
        self.cards = self.cards[:start_idx]  # Обновляем список карт в столбце
        return removed_cards  # Возвращаем удаленные карты

    def draw(self, screen, start_pos):
        x, y = start_pos  # Начальная позиция для рисования карт в столбце
        for card in self.cards:  # Для каждой карты в столбце
            card.draw(screen, (x, y))  # Рисуем карту
            y += 30  # Смещение для следующей карты в столбце

    def get_top_card(self):
        if self.cards:  # Если в столбце есть карты
            return self.cards[-1]  # Возвращаем верхнюю карту в столбце
        return None  # Если столбец пуст, возвращаем None

# Класс для представления базовой стопки (фундамента)
class Foundation:
    def __init__(self):
        self.cards = []  # Список карт в базовой стопке

    def add_card(self, card):
        self.cards.append(card)  # Добавляем карту в базовую стопку

    def get_top_card(self):
        if self.cards:  # Если в базовой стопке есть карты
            return self.cards[-1]  # Возвращаем верхнюю карту в базовой стопке
        return None  # Если стопка пуста, возвращаем None

    def can_add_card(self, card):
        if not self.cards:  # Если в стопке нет карт
            return card.value == 1  # Туз должен быть первым
        top_card = self.get_top_card()  # Получаем верхнюю карту в стопке
        return card.suit == top_card.suit and card.value == top_card.value + 1  # Карты должны быть одной масти и возрастающего значения

    def draw(self, screen, pos):
        x, y = pos  # Позиция для рисования базовой стопки
        if self.cards:  # Если в стопке есть карты
            self.cards[-1].draw(screen, (x, y))  # Рисуем верхнюю карту в стопке
        else:  # Если стопка пуста
            pygame.draw.rect(screen, (255, 255, 255), (x, y, back_image.get_width(), back_image.get_height()), 2)  # Рисуем пустую стопку

# Класс для представления колоды карт
class Deck:
    def __init__(self):
        self.cards = []  # Список карт в колоде

    def add_card(self, card):
        self.cards.append(card)  # Добавляем карту в колоду

    def draw(self, screen, pos):
        x, y = pos  # Позиция для рисования колоды
        if self.cards:  # Если в колоде есть карты
            back_image_rect = back_image.get_rect(topleft=(x, y))  # Получаем прямоугольник изображения обратной стороны карты
            screen.blit(back_image, back_image_rect)  # Рисуем обратную сторону карты
        else:  # Если колода пуста
            pygame.draw.rect(screen, (255, 255, 255), (x, y, back_image.get_width(), back_image.get_height()), 2)  # Рисуем пустую колоду

    def draw_card(self):
        if self.cards:  # Если в колоде есть карты
            return self.cards.pop()  # Возвращаем верхнюю карту из колоды

    def refill(self, draw_pile):
        while draw_pile:  # Пока есть карты в стопке вытянутых карт
            card = draw_pile.pop()  # Берем карту из стопки вытянутых карт
            card.face_up = False  # Переворачиваем карту лицевой стороной вниз
            self.cards.append(card)  # Возвращаем карту в колоду

# Подготовка колоды и раздача карт по столбцам
columns = [Column() for _ in range(7)]  # Создаем 7 столбцов для карт
foundations = [Foundation() for _ in range(4)]  # Создаем 4 базовые стопки
deck = Deck()  # Создаем колоду
draw_pile = []  # Создаем стопку вытянутых карт

suits = ['hearts', 'diamonds', 'clubs', 'spades']  # Масти карт
values = ['ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'jack', 'queen', 'king']  # Значения карт
colors = {'hearts': 'red', 'diamonds': 'red', 'clubs': 'black', 'spades': 'black'}  # Цвета карт (красный и черный)
# Создаем и добавляем карты в колоду
deck.cards = [Card(f"{value}_of_{suit}", card_images[f"{value}_of_{suit}"], values.index(value) + 1, suit, colors[suit]) for suit in suits for value in values]
random.shuffle(deck.cards)  # Перемешиваем колоду

# Раздаем карты по столбцам
for i in range(7):
    for j in range(i + 1):
        card = deck.cards.pop()  # Вытягиваем карту из колоды
        if j == i:  # Переворачиваем верхнюю карту в столбце лицевой стороной вверх
            card.face_up = True
        columns[i].add_card(card)  # Добавляем карту в столбец

# Переменные для отслеживания выбранной карты
selected_cards = []  # Список выбранных карт
selected_column = None  # Столбец, из которого выбраны карты
selected_deck_card = None  # Выбранная карта из колоды
offset_x, offset_y = 0, 0  # Смещение для перемещения карты

# Проверка возможности размещения карты на другой карте
def can_place_card(card_to_place, target_card):
    return card_to_place.value == target_card.value - 1 and card_to_place.color != target_card.color


# Обработка события отпускания кнопки мыши
def handle_mouse_button_up(mouse_x, mouse_y):
    global selected_cards, selected_column, selected_deck_card

    if selected_cards:  # Если есть выбранные карты из столбца
        card_placed = False  # Флаг, указывающий на успешное размещение карты

        for column in columns:  # Перебираем все столбцы
            if column == selected_column:  # Пропускаем столбец, из которого были взяты карты
                continue

            if not column.cards:  # Если столбец пуст
                if selected_cards[0].value == 13:  # Короля можно перемещать на пустое место
                    column.cards.extend(selected_cards)  # Добавляем карты в столбец
                    card_placed = True  # Устанавливаем флаг успешного размещения
                    break  # Выходим из цикла, так как карты успешно размещены
            else:
                top_card = column.get_top_card()  # Получаем верхнюю карту в текущем столбце
                if can_place_card(selected_cards[0], top_card):  # Проверяем, можно ли поместить выбранную карту на верхнюю карту столбца
                    column.cards.extend(selected_cards)  # Добавляем карты в столбец
                    card_placed = True  # Устанавливаем флаг успешного размещения
                    break  # Выходим из цикла, так как карты успешно размещены

        if not card_placed:  # Если карты не были размещены в столбцах
            for foundation in foundations:  # Перебираем все базовые стопки
                if foundation.can_add_card(selected_cards[0]) and len(selected_cards) == 1:  # Проверяем, можно ли добавить карту в базовую стопку
                    for card in selected_cards:  # Добавляем все выбранные карты в базовую стопку
                        foundation.add_card(card)
                    card_placed = True  # Устанавливаем флаг успешного размещения
                    break  # Выходим из цикла, так как карты успешно размещены

        if card_placed:  # Если карты были успешно размещены
            selected_column.remove_cards(len(selected_column.cards))  # Удаляем карты из исходного столбца
            if selected_column.cards and not selected_column.get_top_card().face_up:  # Если в столбце остались карты и верхняя карта лицевой стороной вниз
                selected_column.get_top_card().face_up = True  # Переворачиваем верхнюю карту лицевой стороной вверх
        else:  # Если карты не были размещены
            selected_column.cards.extend(selected_cards)  # Возвращаем карты в исходный столбец

        selected_cards = []  # Очищаем список выбранных карт
        selected_column = None  # Сбрасываем выбранный столбец

    elif selected_deck_card:  # Если была выбрана карта из колоды
        card_placed = False  # Флаг, указывающий на успешное размещение карты

        for column in columns:  # Перебираем все столбцы
            if not column.cards:  # Если столбец пуст
                if selected_deck_card.value == 13:  # Короля можно перемещать на пустое место
                    column.add_card(selected_deck_card)  # Добавляем карту в столбец
                    card_placed = True  # Устанавливаем флаг успешного размещения
                    break  # Выходим из цикла, так как карта успешно размещена
            else:
                top_card = column.get_top_card()  # Получаем верхнюю карту в текущем столбце
                if can_place_card(selected_deck_card,
                                  top_card):  # Проверяем, можно ли поместить выбранную карту на верхнюю карту столбца
                    column.add_card(selected_deck_card)  # Добавляем карту в столбец
                    card_placed = True  # Устанавливаем флаг успешного размещения
                    break  # Выходим из цикла, так как карта успешно размещена

        if not card_placed:  # Если карта не была размещена в столбцах
            for foundation in foundations:  # Перебираем все базовые стопки
                if foundation.can_add_card(selected_deck_card):  # Проверяем, можно ли добавить карту в базовую стопку
                    foundation.add_card(selected_deck_card)  # Добавляем карту в базовую стопку
                    card_placed = True  # Устанавливаем флаг успешного размещения
                    break  # Выходим из цикла, так как карта успешно размещена

        if not card_placed:  # Если карта не была размещена
            draw_pile.append(selected_deck_card)  # Возвращаем карту в стопку вытянутых карт

        selected_deck_card = None  # Сбрасываем выбранную карту из колоды

while True:
    mouse_x, mouse_y = pygame.mouse.get_pos()  # Получаем текущие координаты мыши
    for event in pygame.event.get():  # Обрабатываем все события
        if event.type == pygame.QUIT:  # Если событие - выход
            pygame.quit()  # Завершаем работу Pygame
            sys.exit()  # Завершаем программу

        elif event.type == pygame.MOUSEBUTTONDOWN:  # Если нажата кнопка мыши
            mouse_x, mouse_y = event.pos  # Получаем позицию мыши
            deck_rect = back_image.get_rect(topleft=(50, 50))  # Прямоугольник для колоды
            if deck_rect.collidepoint(mouse_x, mouse_y):  # Если кликнули по колоде
                if deck.cards:  # Если в колоде есть карты
                    drawn_card = deck.draw_card()  # Вытягиваем карту из колоды
                    drawn_card.face_up = True  # Переворачиваем карту лицевой стороной вверх
                    draw_pile.append(drawn_card)  # Добавляем карту в стопку вытянутых карт
                else:
                    deck.refill(draw_pile)  # Повторное листание колоды
                continue
            if draw_pile:
                drawn_card_rect = draw_pile[-1].image.get_rect(topleft=(150, 50))  # Прямоугольник для верхней карты в стопке вытянутых карт
                if drawn_card_rect.collidepoint(mouse_x, mouse_y):  # Если кликнули по верхней карте в стопке вытянутых карт
                    selected_deck_card = draw_pile.pop()  # Выбираем эту карту
                    break
            for column in columns:  # Проверяем клик по картам в столбцах
                if column.cards:
                    for idx, card in enumerate(column.cards):
                        card_rect = card.image.get_rect(topleft=(50 + columns.index(column) * 100, 150 + 30 * idx))  # Прямоугольник для карты в столбце
                        if card_rect.collidepoint(mouse_x, mouse_y) and card.face_up:  # Если кликнули по карте лицевой стороной вверх
                            selected_cards = column.cards[idx:]  # Выбираем карты начиная с этой
                            selected_column = column  # Запоминаем столбец, из которого выбраны карты
                            offset_x = card_rect.x - mouse_x  # Рассчитываем смещение по X для перемещения карты
                            offset_y = card_rect.y - mouse_y  # Рассчитываем смещение по Y для перемещения карты
                            column.cards = column.cards[:idx]  # Удаляем выбранные карты из столбца
                            break
                    if selected_cards:
                        break

        elif event.type == pygame.MOUSEBUTTONUP:  # Если отпустили кнопку мыши
            handle_mouse_button_up(mouse_x, mouse_y)  # Обрабатываем отпускание кнопки мыши

        elif event.type == pygame.MOUSEMOTION:  # Если мышь перемещается
            if selected_cards or selected_deck_card:  # Если есть выбранные карты
                mouse_x, mouse_y = event.pos  # Обновляем координаты мыши

    screen.fill((0, 128, 0))  # Заливаем экран зеленым цветом

    # Отрисовка колоды и стопки вытянутых карт
    deck.draw(screen, (50, 50))  # Рисуем колоду
    if draw_pile:  # Если есть вытянутые карты
        draw_pile[-1].draw(screen, (150, 50))  # Рисуем верхнюю карту из стопки вытянутых карт

    # Отрисовка базовых стопок
    foundation_x = 300  # Начальная позиция для базовых стопок
    for foundation in foundations:  # Для каждой базовой стопки
        foundation.draw(screen, (foundation_x, 50))  # Рисуем базовую стопку
        foundation_x += 100  # Смещаемся вправо для следующей стопки

    # Отрисовка карт в столбцах
    start_x = 50  # Начальная позиция для столбцов
    for column in columns:  # Для каждого столбца
        column.draw(screen, (start_x, 150))  # Рисуем столбец карт
        start_x += 100  # Смещаемся вправо для следующего столбца

    # Отрисовка перемещаемых карт
    if selected_cards:  # Если есть выбранные карты
        for idx, card in enumerate(selected_cards):  # Для каждой выбранной карты
            screen.blit(card.image, (mouse_x + offset_x, mouse_y + offset_y + 30 * idx))  # Рисуем карту с учетом смещения
    elif selected_deck_card:  # Если выбрана карта из колоды
        screen.blit(selected_deck_card.image, (mouse_x, mouse_y))  # Рисуем карту

    pygame.display.flip()  # Обновляем экран
